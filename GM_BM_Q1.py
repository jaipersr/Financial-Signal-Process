# -*- coding: utf-8 -*-
"""
Ryan Jaipersaud
ECE-478: Financial Signal Processing
11/18/2018
Project: Simulating Stochastic Differential Equations
The purpose of the code below is to solve a stochastic differential equation of 
the form dS = a*S*dt + s*S*dW in the discrete time case. dW is generated using a
gaussian ~N(0,delta) where delta is the time step. Monte Carlo is used to get
an estimate of S[N/2] by averaging over L paths. 10 Geometric Brownian Motion 
undiscounted paths are plotted. For each of the 10 undiscoutned paths, 1000 discounted 
paths eminating from the half way point in the path [N/2] are generated from 
[N/2 + 1] to [N]. By taking an average of the 1000 paths and using the 
Martingale property, and estimate of S[N/2] is found. The MSE between the actual 
S[N/2] generated by the geometric brownian motion and the one generated by the 
martingale approach are calculated for all 10 paths.
"""

import numpy as np
from pandas import DataFrame
import matplotlib.pyplot as plt

# This function is responsible for generating stock paths under the actual probabilites
def stock_paths(N,L):
    global alpha,sigma,r,delta
    
    S_paths = np.zeros((1,N+1)) # This will hold all stock paths under actual probabilities
    
    for j in range(L): # The outer for loop generates the number of paths specified
        
        S = np.array([1]) # S is a specific path being generated
        for i in range(N): # The inner for loop determines how long each path should be
            dW = np.random.normal(0,np.sqrt(delta),1) # At each iteration generate 1 number from a gausian distribution with mean 0 and st dev delta
            dS = alpha*S[i]*delta + sigma*S[i]*dW # Computes incremental change in S
            S = np.append(S,S[i] + dS) # Computes the stock price for the next iteration  
        S_paths = np.vstack((S_paths,S)) # Adds the path that was just generated to the matrix containing all paths
        
    S_paths = np.delete(S_paths, (0), axis=0) # removes initial row 
    return S_paths

# This will determine the discounted stock prices for the first 10 paths
# in S_paths that was generated by stock_paths(). However, this will be 
# under the risk neutral probabilities 
def discounted_stock_prices(N,L,S_paths):
    global alpha,sigma,r,t,delta,T
    
    X_paths = np.zeros((1,int(N/2)+1)) # This will hold all discounted stock paths under the risk neutral probabilities
    S_prime = np.array([]) # This will hold the average stock price generated using the martingale approach 
    
    for j in range(10): # Looks at the first 10 paths of S_paths
        
        # for each path in S this will generate L =1000 paths eminating from S[N/2]
        for k in range(L):
            X0 = S_paths[j,int(N/2)] # This sets the initial condition X(t) = S(t)
            X = np.array([X0]) # X is a specific path being generated
            
            # This generates a single path eminating from  S[N/2]
            for i in range(int(N/2)):
                #martingale approach
                dW_tilde = np.random.normal(0,delta,1) # At each iteration  1 number is drawn from a gausian distribution with mean 0 and st dev delta
                dX = sigma*np.exp(-r*(T-t[i+ int(N/2)]))*S_paths[j,int((N/2)+1 + i)]*dW_tilde # dX = s*e^(-r(T-t))*S(t)*dW_tilde
                X = np.append(X, X[i] + dX ) # appends the discounted stock price under risk neutral probabilities for the next iteration
            
            # Adds the path that was just generated to the matrix containing all paths
            # each row of X_paths represents a specifc path that lives in 1 by N/2
            X_paths  = np.vstack((X_paths ,X)) 
        
        X_paths = np.delete(X_paths, (0), axis=0) # removes initial row
        X_paths_avr = np.mean(X_paths,axis =0) # This is the average path from N/2 to N 
        
        # S = X*e^(r(T-t)) 
        # This uses the martingale approach and pull backs the last element of X 
        # to estimate S[N/2]
        S_prime = np.append(S_prime,X_paths_avr[-1]*np.exp(r*(t[-1]-t[int(N/2)])))  
        
    return S_prime
    

# Parameters
N =100 # length of walk
L = 1000 # number of paths 
alpha = 0.1/N
sigma = alpha
r = alpha/3
T = 1 # end time
t = (T*np.arange(N+1)/N) # Creates a time vector from 0 to T = 1
delta = T/N # delta is constant

S_paths = stock_paths(N,L) # randomly generated stock paths that live in L by N
print('-----------------------------------Part A------------------------------')
S_avr_N2 = np.mean(S_paths[:,int(N/2)]) # This computes the average path under the actual probabilities
print('S[N/2] = ', S_avr_N2, ' with N = ', N, ' and L = ', L)

#-----------------------------------------Part B-------------------------------

plt.plot( t.T,S_paths[0:10,:].T)
plt.xlabel('t')
plt.ylabel('S(t)')
plt.title('Part B: Super Imposed image of 10 paths')

print('-----------------------------------Part C------------------------------')
S_prime = discounted_stock_prices(N,1000,S_paths) # estimates the stock price given an already generated S_paths using the martingale approach
S_prime = np.array([S_prime]).T
S_actual = np.reshape(S_paths[0:10,int(N/2)],(10,1)) # actual stock price at S[N/2]

averages = np.hstack((S_actual,S_prime))
df = DataFrame(data = averages, columns = ['S[N/2]','S_hat[N/2]'])

print('For L = ', L, 'And N = ', N )
print('The average stock values at N/2 under the actual probabilities and the risk neutral are as follows.')
print(df)
print('dX = 0*dt + s*e^(-r(T-t))*S*dW~')
print('Therefore X[N] = X[N/2] + Y, where Y is a random variable independed of F_N/2')
print('Y has mean 0 and thus E~(X|F_N/2) = X[N/2]')
print('-----------------------------------Part D------------------------------')
print('The MSE was found to be: ', np.mean((S_prime - S_actual)**2))
print('This is an estimate of the variance')









